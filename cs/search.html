<!DOCTYPE html>
<html lang="en">
	<head>
		<div id="head_cheese"> </div>
		<script src="../sidebar1layer.js"> </script>
	    <link rel="icon" href="../icons/calculator-8x.png">
	</head>
	<body>
		<div class="sidenav" id="cheese">
		</div>
		<div class="main">
			<a href="../cs.html"><button type="button"> Back </button></a>
			
		</div>
		<div class="paragraph">
			<h2>Searches: Djikistra, Greedy, AStar</h2>
			<h5>Date: 06/21/2018</h5>
			</br>
			<div class="image">
				<img src="Images/Search1.png" alt="Searching" width="350" height="350">
			</div>
			<h6>The initial image</h6>
			<div class="image">
				<img src="Images/Search2.png" alt="Solved!" width="350" height="350">
			</div>
			<h6>The final image, using A Star search</h6>
			<p>
				In this search program, there exists a square grid of squares. The red square represents the starting point, the green square represents the ending point, the black squares represent walls (the path cannot go through), the blue squares represent the calculated path and the yellow squares represent all tiles searched, or the tiles that the program looked at in the end. <br><br>
				The Djikistra's algorithm can be seen like a breath-first search: basically, it searches all closest tiles from the origin, then discards it. It repeats until it reaches the end point, and then it returns the shortest path via the distance from the end to the start, decreasing.<br>

				The Greedy algorithm is a depth-first search that is committed: basically, it focuses solely on the tiles that are closest to the end point without regard to walls and other things, which while is really fast and relatively accurate can cause the algorithm to miss a really short bottleneck, for instance.<br>

				The A Star search combines the two. If f(x) is the distance of the tile from the start point and g(x) is the distance of the tile to the end point (f(x) is djikistra and g(x) is greedy), then the algorithm calculates and then focuses on the tiles with the lowest f(x) + g(x) value.<br>

				It as a result also means Djikistra and A Star will always return the shortest path, but maybe not greedy. <br><br>

				This was a really hard challenge as the computer will always return a weird path during the testing days. Some problems that occurred included: <br>
				The path will be flipped according to the line y = x. In other words, the matrix that stores the values are storing it as (x,y) instead of (y,x) according to java standards. <br>
				The path will not return correctly. While the tile sorting algorithm works, the returning algorithm was just told to follow the path, which resulted in the algorithm picking whatever tile that were sorted, resulting in hilariously weird paths. As a result, I had to implement Djikistra's algorithms on the tile returned values an additional time to ensure the path was correct.
			</p>
			
			<br>
			<br>
			<br>
			<br>
		</div>
		<script> cheese(); </script>
	</body>
 </html>